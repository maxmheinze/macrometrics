---
title: '**Advanced Macroeconometrics -- Assignment 1**'
author: 
  - "Siegfried Hammer (h12229325@wu.ac.at)"
  - "Max Heinze (h11742049@wu.ac.at)"
  - "Tim Koenders (h12215486@wu.ac.at)"
date: "April 19, 2023"
output: 
  pdf_document:
    includes:
      in_header: !expr file.path(rprojroot::find_rstudio_root_file(), "helper", "wrap_code.tex")
header-includes: \usepackage{tcolorbox}
papersize: a4
geometry: margin = 2cm
urlcolor: Mahogany
---

```{r, setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
```

```{=tex}
\begin{tcolorbox}
\centering \itshape The executable code that was used in compiling the assignment is available on GitHub at \url{https://github.com/maxmheinze/macrometrics}.
\end{tcolorbox}
```
# Exercise 1

First, we read in the data set, removing the first column indicating the recommended transformation.

```{r, echo = TRUE, results = "hide"}
# Header ------------------------------------------------------------------

rm(list = ls())
gc()

pacman::p_load(
  tidyverse,
  urca
  )


# Read in Data ------------------------------------------------------------

fred <- read.csv("./assignment1/data/fred.csv")[-1,]
```

Next, we create the desired function `ts_explode()`. Along with the vector to be transformed, it asks for a specification of whether the data is ordered with the latest or earliest value first. It takes the earliest value first as default.

```{r, echo = TRUE}
# Create the function -----------------------------------------------------

ts_explode <- function(input_vector, start_with_latest = FALSE) {
  # The function is called ts_explode because a single vector explodes into an entire data frame. Boom!
  
  # Package dplyr required for lag() function
  require(dplyr)
  
  # Reverse input vector if user specifies it is sorted latest to earliest
  input_vector <- if (start_with_latest == FALSE) {
    input_vector
  } else {
    rev(input_vector)
  } 
  
  # Do the transformations, assign transformed vectors
  original <- input_vector
  log_transformed <- log(input_vector)
  mom_growth <- input_vector/dplyr::lag(input_vector, 1) - 1
  yoy_growth <- input_vector/dplyr::lag(input_vector, 12) - 1
  yoy_growth_lagged <- dplyr::lag(input_vector, 12)/dplyr::lag(input_vector, 24) - 1
  
  # Create a data frame to export, reverse ordering back to original in case start_with_latest = TRUE was specified
  export_df <- if (start_with_latest == FALSE) {
    data.frame(original, log_transformed, mom_growth, yoy_growth, yoy_growth_lagged)
  } else {
    data.frame(original = rev(original), 
               log_transformed = rev(log_transformed), 
               mom_growth = rev(mom_growth), 
               yoy_growth = rev(yoy_growth), 
               yoy_growth_lagged = rev(yoy_growth_lagged))
  }
  
  # Display warnings regarding ordering and units of growth rates
  warning("By default, ts_explode() assumes that values are ordered from earliest to latest. If your vector is ordered from latest to earliest, specify `start_with_latest = TRUE`!")
  warning("Growth rates are given in decimals, not in percent!")
  
  # Return the data frame
  return(export_df)
}
```

Using `ts_explode()`, we create the data frame `ind_prod` including all transformations of the `INDPRO` variable. We bind the data frame together with the date column, which we transform from character to date. All other changes in the resulting data frame are of cosmetic nature.

```{r, warning=FALSE}
# Prepare Industrial Production Data Frame --------------------------------

ind_prod <- fred$sasdate %>%
  cbind(ts_explode(fred$INDPRO)) %>%
  as_tibble() %>%
  mutate(date = lubridate::mdy(`.`)) %>%
  select(-`.`) %>%
  relocate(date, .before = original)
```

Next, we plot both the logged variable and the year-on-year growth rate.

```{r, echo = TRUE, out.width="50%", fig.align='center'}
# Create Log Plot ---------------------------------------------------------

ind_prod %>%
  ggplot() +
  geom_line(aes(x = date, y = log_transformed)) +
  labs(title = "U.S. Industrial Production (logged)",
       x = "Date",
       y = "Log of Industrial Production") +
  ylim(3,5) +
  theme_bw()


# Create Growth Plot ------------------------------------------------------

ind_prod %>%
  ggplot() +
  geom_line(aes(x = date, y = yoy_growth)) +
  labs(title = "U.S. Industrial Production (year-on-year growth)",
       x = "Date",
       y = "Year-on-Year Growth of Industrial Production") +
  theme_bw()
```

The plots above depicts the logged time series of U.S. industrial production and its corresponding year-on-year growth rates. The logged time series of U.S. industrial production appears to exhibit a generally upward trend over time. The logged time series of U.S. industrial production also shows evidence of cyclical patterns, with periods of expansion and contraction occurring in a cyclical manner. There are also periodic fluctuations in the year-on-year growth rates, which suggests the presence of seasonality in U.S. industrial production. 

Next assess the properties of both logged industrial production and its yearly growth rate.

```{r, echo = TRUE, out.width="50%", fig.align='center'}

# Assessing the time series properties ----------------------------------------

# ACF plot and ADF test(s) of Logged Industrial Production

stats::acf(ind_prod$log_transformed[!is.na(ind_prod$log_transformed)], main = "ACF of Logged Industrial Production")

urtest1a = ur.df(ind_prod$log_transformed[!is.na(ind_prod$log_transformed)], type = "trend", selectlags = "AIC")
summary(urtest1a)

urtest2a = ur.df(ind_prod$log_transformed[!is.na(ind_prod$log_transformed)], type = "drift", selectlags = "AIC")
summary(urtest2a)

# ACF plot and ADF test(s) of Year-on-Year Growth Rate

stats::acf(ind_prod$yoy_growth[!is.na(ind_prod$yoy_growth)], main = "ACF of YoY Growth of Industrial Production")

urtest1b = ur.df(ind_prod$yoy_growth[!is.na(ind_prod$yoy_growth)], type = "trend", selectlags = "AIC")
summary(urtest1b)

urtest2b = ur.df(ind_prod$yoy_growth[!is.na(ind_prod$yoy_growth)], type = "drift", selectlags = "AIC")
summary(urtest2b)

```

The ACF of Logged Industrial Production reveals a highly persistent nature of the time series with significant autocorrelation coefficients, particularly between Logged Industrial Production and its first five lags, which are extremely close to 1. The autocorrelation coefficients remain highly significant in the displayed laggs. This highly persistent nature suggests potential non-stationarity in the series. For a more appropriate procedure, we apply the Augmented Dickey-Fuller (ADF) unit root tests. 

Type: "trend" (urtest1a)
H0: The time series is random walk around a trend
H1: The time series is trend-stationary

As the coefficient of trend (tt) is insignificant, we never apply the ADF test with drift and trend. Instead, we move on to the second equation including only the drift component.

Type: "drift" (urtest2a)
H0: The time series is random walk around a drift 
H1: The time series is (log-level) stationary around a drift

As the drift component is significant, and the absolute value of the test-statistic (2.5263) is below all the critical values for conventional significance levels, we conclude that we fail to reject the null hypothesis that the time series is random walk around a drift. 

Thus, we conclude that Logged Industrial Production is I(1).

The ACF of YoY Growth rate of Industrial Production shows positive persistence, but to a lesser extent compared to the former series. The correlation coefficient decreases relatively quickly and even turns significantly negative after the 17th lag, indicating the presence of a pattern or cycle in the data at specific time lags. Now we apply the Augmented Dickey-Fuller (ADF) unit root tests. 

Type: "trend" (urtest1b)
H0: The time series is random walk around a trend
H1: The time series is trend-stationary

As the coefficient of trend (tt) is insignificant, we never apply the ADF test with drift and trend. Instead, we move on to the second equation including only the drift component.

Type: "drift" (urtest2b)
H0: The time series is random walk around a drift 
H1: The time series is stationary around a drift

As the drift component is significant, and the absolute value of the test-statistic (5.6443) is above all the critical values for conventional significance levels, we conclude that we reject the null hypothesis that the time series is random walk around a drift. 

Thus, we conclude that the YoY Growth of Industrial Production is I(0). 

```{r, echo = TRUE, out.width="50%", fig.align='center'}
# Estimate AR model ---------------------------------------------------------

ar_model_yoygrowth = ar.ols(ind_prod$yoy_growth[!is.na(ind_prod$yoy_growth)])
summary(ar_model_yoygrowth)

# Generate forecasts for the next year
forecasts <- predict(ar_model_yoygrowth, n.ahead = 12)
print(forecasts)

# Extract the forecasted values and the corresponding time period
forecasted_values <- as.vector(forecasts$pred)
time_period <- seq_along(forecasted_values) + length(ind_prod$yoy_growth)

# Plot the forecasts
plot(time_period, forecasted_values, type = "l", 
     main = "AR Model Forecasts", xlab = "Time", ylab = "Forecasts")

# Average YoY growth rate
mean(ind_prod$yoy_growth[!is.na(ind_prod$yoy_growth)])

# Forecast change in original time series based on forecasted year-on-year growth rate
last_observed_original <- tail(ind_prod$original, n = 1)
forecasted_change <- last_observed_original * forecasted_values

# Combine original time series with forecasted change
forecasted_original <- c(ind_prod$original, forecasted_change)

# Define time periods for forecasted changes
time_period_forecasted_change <- seq_along(forecasted_original)

# Plot forecasted changes
plot(time_period_forecasted_change, forecasted_original, type = "l", 
     xlab = "Time Period", ylab = "Forecasted Changes",
     main = "Forecasted Changes in Original Time Series")

```

The lag order is determined by default in the ar.ols() function using the Akaike Information Criterion (AIC) as the method for order selection. AIC is a model selection criterion that balances model goodness of fit and complexity. Lower AIC values are preferred. The ar.ols() function computes the AIC value for different lag orders and selects the lag order that minimizes the AIC as the optimal lag order for the AR model. 


If the AR model is capturing the underlying patterns wel, then as the YoY growth rate of industrial production is stationary, the forecasts are likely to converge towards their long-run average of around 0.026 (2.6%).

```{r, echo = TRUE, out.width="50%", fig.align='center'}

# Bonus -----------------------------------------------------------------------




```

